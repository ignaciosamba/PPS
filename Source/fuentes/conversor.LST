C51 COMPILER V9.53.0.0   CONVERSOR                                                         05/08/2015 16:53:49 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE CONVERSOR
OBJECT MODULE PLACED IN conversor.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe conversor.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include "headers.h"
   2          #include "conversor.h"
   3          int cont = 0;
   4          
   5          unsigned long convertir(void)
   6          {
   7   1              static LONGDATA rawValue;
   8   1              unsigned long mV;
   9   1              
  10   1              while (!AD0INT);
  11   1              AD0INT = 0;
  12   1      
  13   1                 // Copy the output value of the ADC
  14   1              rawValue.Byte[Byte3] = 0x00;
  15   1              rawValue.Byte[Byte2] = (unsigned char)ADC0H;
  16   1              rawValue.Byte[Byte1] = (unsigned char)ADC0M;
  17   1              rawValue.Byte[Byte0] = (unsigned char)ADC0L;
  18   1      
  19   1              //                           Vref (mV)
  20   1              //   measurement (mV) =   --------------- * result (bits)
  21   1              //                       (2^24)-1 (bits)
  22   1              //
  23   1              //   measurement (mV) =  result (bits) / ((2^24)-1 (bits) / Vref (mV))
  24   1              //
  25   1              //
  26   1              //   With a Vref (mV) of 2500:
  27   1              //
  28   1              //   measurement (mV) =  result (bits) / ((2^24)-1 / 2500)
  29   1              //
  30   1              //   measurement (mV) =  result (bits) / ((2^24)-1 / 2500)
  31   1              //
  32   1              //   measurement (mV) =  result (bits) / (16777215 / 2500)
  33   1              //
  34   1              //   measurement (mV) =  result (bits) / (6710)
  35   1      
  36   1              mV = rawValue.result / 6710;        // Because of bounds issues, this
  37   1                                                 // calculation has been manipulated as
  38   1                                                 // shown above
  39   1                                                 // (i.e. 2500 (VREF) * 2^24 (ADC result)
  40   1                                                 // is greater than 2^32)
  41   1      
  42   1              return mV;
  43   1      
  44   1      }
  45          /**
  46           * @brief por ahora no envia un carajo.. imprime en la UART nomas
  47           * @details [long description]
  48           */
  49          void enviar_dato(unsigned long dato)
  50          {
  51   1              //unsigned long dato2;
  52   1              //dato2=100;
  53   1              printf("voltaje: %8ld mV\n",dato);
  54   1              // dato_convertido = dato;
  55   1              // f_enviar_dato = true;
C51 COMPILER V9.53.0.0   CONVERSOR                                                         05/08/2015 16:53:49 PAGE 2   

  56   1      
  57   1              // if(ADC0MUX == 0x08)
  58   1              //    pin_actual = 0;
  59   1              // else if(ADC0MUX == 0x18)
  60   1              //    pin_actual = 1;
  61   1              // else if(ADC0MUX == 0x28)
  62   1              //    pin_actual = 2;
  63   1              // else if(ADC0MUX == 0x38)
  64   1              //    pin_actual = 3;
  65   1              // else if(ADC0MUX == 0x48)
  66   1              //    pin_actual = 4;
  67   1              // else if(ADC0MUX == 0x58)
  68   1              //    pin_actual = 5;
  69   1              // else if(ADC0MUX == 0x68)
  70   1              //    pin_actual = 6;
  71   1              // else if(ADC0MUX == 0x78)
  72   1              //    pin_actual = 7;
  73   1      }
  74          
  75          /**void cambiar_pin (void)
  76          {
  77                  
  78                  if(ADC0MUX == 0x78)
  79                  {
  80          
  81                                  ADC0MUX = 0x08;
  82                                  cont = 0;
  83                                  printf("Entrada: %1d, ",cont);
  84                                  cont++;
  85                  }
  86                  else
  87                  {
  88                            printf("Entrada: %1d, ",cont);
  89                            ADC0MUX = ((ADC0MUX & 0xf0) >> 4) | ((ADC0MUX & 0x0f) << 4); //Swapeo los 4 MSB con los 4 LSB para aum
             -entar en uno el LSB
  90                            ADC0MUX++;
  91                            ADC0MUX = ((ADC0MUX & 0xf0) >> 4) | ((ADC0MUX & 0x0f) << 4); //Swapeo una vez mas asi me queda increme
             -ntado los 4 MSB y asi me movi de puerto. 
  92                            cont++;
  93                  }
  94          }**/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     52    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
