aca estaria bueno ir poniendo cosas...

PLATAFORMA DE TESTS

la plataforma de tests esta hecha. la idea es que test_global corre todos los otros tests. asi que cada vez que se quiere agregar un archivo de test hay que incluirlo en test_global. adentro de cada archivo de test van las funciones andando y test global las corre y controla que den todas bien.


IDEAS DE TESTS

-para testear al adc, que iniciamos la configuracion y analizamos el registro en el que se activa el bit de end of conversion, si se activa, el adc anda por lo menos. Ya mas tarde cuando esten bien hechas las funciones de configuracion, hay que testear valores esperados para el adc dada una configuracion.


POR AHORA

por ahora lo que vamos a hacer, para no romperme la cabeza con la configuracion de los pines. es que lea todos los pines de pecho y pase toda la informacion siempre. despues lo vamos detallando de a poco.
Entonces por ahora va a haber un primer prototipo.. no tiene un carajo de configuracion. lo conectas y de pecho te entra a mandar informacion de las 8 patas del adc en modo single ended.

-lucho

PRIMER PROTOTIPO

va a entregar los datos que reciba de las 8 patas todo el tiempo a una frecuencia fija en modo single-ended. Con una tension de referencia de 2.5V. Cuando tiene el dato listo lo imprime por la UART.

-lucho

7/5

ya pudimos hacer andar el primer prototipo con solo el adc andando y tirando la info de todas las patas de manera continua. ahora estamos intentando configurar alguna de las patas.

-lucho

8/5

Orlando nos dijo hoy que el gain del adc puede variar segun la temperatura y el tiempo que hace que esta convirtiendo y nos dejo bastante en offside.. hay que hacer algunas pruebas

-lucho

14/5

PUNTOS CLAVE DE UTILIZACION DE LA FLASH

- El monitor de VDD tiene que estar habilitado cuando se esta escribiendo o borrando la flash
- Deshabilitar las interrpupciones globales antes de setear PSWE a 1
- Hay que tener cuidado con los modelos de memoria Large y Compact, porque usan xdata y pdata para variables de usuario, y ambos generan codigos de escritura MOVX
- Secuencias Lock y Key deben generarse antes de cada operacion de escritura o borrado. 
- intentos de escritura, lectura o borrado de secciones de memoria localizadas en espacio reservado generaran un reset del dispositivo
- El CPU se detiene en las operaciones de lectura y escritura de la flash, pero los dispositivos perifericos siguen andando
- Las interrupciones que surgen durante una operacion de escritura o borrado se pospondran hasta que se complete la operacion
- La pagina de la flash que contiene el o los bytes del Lock no se pueden borrar desde el codigo de aplicacion


Para escribir en la memoria flash se usa la instruccion MOVX. Por defecto, esta instruccion carga datos en la XRAM, pero cambiando el registro PSCTL se puede modificar para que escriba en la Flash. Las instrucciones MOVX se neran en C usando punteros de memoria de tipo xdata o pdata.

Solo se puede escribir en memoria habiendo borrado todo antes. La instruccion de escritura solo puede poner bits en 0

-lucho

18/5

estoy pensando en un cambio de paradigma de la interfaz con el usuario. como nos estamos quedando sin memoria una buena alternativa es usar MML, que nos permitiria directamente ingresarle comandos al sistema y que el haga bobamente lo que dicen las instrucciones de pechaso, de esa forma tendriamos nomas un case gigante con todas las instrucciones y esas instrucciones llaman funciones que segun los argumentos que tengan las instrucciones hacen lo que queremos. es un lenguaje osea es burdamente crear una especie de mini assembler para el sistema.


SOBRE EL ADC: hay que fijar la frecuencia maxima de muestreo.

-lucho