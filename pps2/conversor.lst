C51 COMPILER V9.51   CONVERSOR                                                             05/13/2015 19:13:12 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CONVERSOR
OBJECT MODULE PLACED IN .\conversor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Source\fuentes\conversor.c BROWSE DEBUG OBJECTEXTEND PRINT(.\converso
                    -r.lst) TABS(2) OBJECT(.\conversor.obj)

line level    source

   1          #include "headers.h"
   2          #include "conversor.h"
   3          int cont = 0;
   4          short int posicion = 0;
   5          short int dato_n;
   6          
   7          
   8          unsigned long convertir(void)
   9          {
  10   1        static LONGDATA rawValue;
  11   1        unsigned long mV;
  12   1        
  13   1        while (!AD0INT);
  14   1        AD0INT = 0;
  15   1      
  16   1           // Copy the output value of the ADC
  17   1        rawValue.Byte[Byte3] = 0x00;
  18   1        rawValue.Byte[Byte2] = (unsigned char)ADC0H;
  19   1        rawValue.Byte[Byte1] = (unsigned char)ADC0M;
  20   1        rawValue.Byte[Byte0] = (unsigned char)ADC0L;
  21   1      
  22   1        //                           Vref (mV)
  23   1        //   measurement (mV) =   --------------- * result (bits)
  24   1        //                       (2^24)-1 (bits)
  25   1        //
  26   1        //   measurement (mV) =  result (bits) / ((2^24)-1 (bits) / Vref (mV))
  27   1        //
  28   1        //
  29   1        //   With a Vref (mV) of 2500:
  30   1        //
  31   1        //   measurement (mV) =  result (bits) / ((2^24)-1 / 2500)
  32   1        //
  33   1        //   measurement (mV) =  result (bits) / ((2^24)-1 / 2500)
  34   1        //
  35   1        //   measurement (mV) =  result (bits) / (16777215 / 2500)
  36   1        //
  37   1        //   measurement (mV) =  result (bits) / (6710)
  38   1      
  39   1        mV = rawValue.result / 6710;        // Because of bounds issues, this
  40   1                                           // calculation has been manipulated as
  41   1                                           // shown above
  42   1                                           // (i.e. 2500 (VREF) * 2^24 (ADC result)
  43   1                                           // is greater than 2^32)
  44   1      
  45   1        return mV;
  46   1      
  47   1      }
  48          /**
  49           * @brief por ahora no envia un carajo.. imprime en la UART nomas
  50           * @details [long description]
  51           */
  52          void enviar_dato(unsigned long dato)
  53          {
  54   1        //unsigned long dato2;
C51 COMPILER V9.51   CONVERSOR                                                             05/13/2015 19:13:12 PAGE 2   

  55   1        //dato2=100;
  56   1        printf("voltaje: %8ld mV\n",dato);
  57   1        // dato_convertido = dato;
  58   1        // f_enviar_dato = true;
  59   1      
  60   1        // if(ADC0MUX == 0x08)
  61   1        //    pin_actual = 0;
  62   1        // else if(ADC0MUX == 0x18)
  63   1        //    pin_actual = 1;
  64   1        // else if(ADC0MUX == 0x28)
  65   1        //    pin_actual = 2;
  66   1        // else if(ADC0MUX == 0x38)
  67   1        //    pin_actual = 3;
  68   1        // else if(ADC0MUX == 0x48)
  69   1        //    pin_actual = 4;
  70   1        // else if(ADC0MUX == 0x58)
  71   1        //    pin_actual = 5;
  72   1        // else if(ADC0MUX == 0x68)
  73   1        //    pin_actual = 6;
  74   1        // else if(ADC0MUX == 0x78)
  75   1        //    pin_actual = 7;
  76   1      }
  77          
  78          void cargar_buffer_single(char dato)
  79          {
  80   1          // printf("sdadasdasdas\n");
  81   1          printf("cargue un 1 en la poscion: %c\n", dato );
  82   1          dato_n = dato - '0';
  83   1          printf("El valor numerico es: %hi\n",dato_n );
  84   1          if(dato >= 0 && dato < 8)
  85   1          buffer_single [dato_n] = 1;
  86   1      }
  87          
  88          short int cambiar_pin()
  89          {
  90   1        while(1)
  91   1        {
  92   2          if (posicion > 7)
  93   2          {
  94   3            posicion = 0;
  95   3          }
  96   2          if(buffer_single[posicion] == 1)
  97   2          {
  98   3            posicion++;
  99   3            return posicion-1;
 100   3          }
 101   2          posicion++;
 102   2        }
 103   1      }
 104          
 105          
 106          
 107          
 108          /*void cambiar_pin (void)
 109          {
 110            
 111            if(ADC0MUX == 0x78)
 112            {
 113          
 114                  ADC0MUX = 0x08;
 115                  cont = 0;
 116                  printf("Entrada: %1d, ",cont);
C51 COMPILER V9.51   CONVERSOR                                                             05/13/2015 19:13:12 PAGE 3   

 117                  cont++;
 118            }
 119            else
 120            {
 121                printf("Entrada: %1d, ",cont);
 122                ADC0MUX = ((ADC0MUX & 0xf0) >> 4) | ((ADC0MUX & 0x0f) << 4); //Swapeo los 4 MSB con los 4 LSB para aum
             -entar en uno el LSB
 123                ADC0MUX++;
 124                ADC0MUX = ((ADC0MUX & 0xf0) >> 4) | ((ADC0MUX & 0x0f) << 4); //Swapeo una vez mas asi me queda increme
             -ntado los 4 MSB y asi me movi de puerto. 
 125                cont++;
 126            }
 127          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    188    ----
   CONSTANT SIZE    =     76    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
